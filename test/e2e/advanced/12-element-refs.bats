#!/usr/bin/env bats
# 12-element-refs.bats — Tests for element references (@e1, @e2, etc.)
#
# Element refs are generated by the snapshot command. Each interactive element
# gets a ref like @e1, @e2, etc. These refs can then be used in place of CSS
# selectors in subsequent commands (click, fill, hover, etc.).
#
# Refs are stored in a WeakRef-based map in the content script. They are
# cleared and regenerated on each snapshot call.

load "../helpers/daemon.bash"
load "../helpers/assertions.bash"
load "../helpers/fixtures.bash"

# ─── Setup / Teardown ────────────────────────────────────────────────

setup() {
  ensure_daemon_ready
}

# ─── Snapshot Generates Refs ──────────────────────────────────────────

@test "snapshot -ic produces element refs" {
  navigate_and_wait "$URL_LOGIN"

  run bcli snapshot -ic
  [ "$status" -eq 0 ]

  # Output should contain @e references
  [[ "$output" == *"@e"* ]]
}

@test "snapshot -ic shows @e1 as first ref" {
  navigate_and_wait "$URL_LOGIN"

  run bcli snapshot -ic
  [ "$status" -eq 0 ]

  # First ref should be @e1
  [[ "$output" == *"@e1"* ]]
}

@test "snapshot -ic shows multiple refs" {
  navigate_and_wait "$URL_LOGIN"

  run bcli snapshot -ic
  [ "$status" -eq 0 ]

  # Login page has username, password, and login button at minimum
  [[ "$output" == *"@e1"* ]]
  [[ "$output" == *"@e2"* ]]
  [[ "$output" == *"@e3"* ]]
}

@test "snapshot refCount matches number of refs" {
  navigate_and_wait "$URL_CHECKBOXES"

  run bcli snapshot -ic
  [ "$status" -eq 0 ]

  # Output should contain refs and we should have at least 2 checkboxes
  [[ "$output" == *"@e1"* ]]
  [[ "$output" == *"@e2"* ]]
}

# ─── Click with Element Ref ──────────────────────────────────────────

@test "click @e ref: click checkbox using element ref" {
  navigate_and_wait "$URL_CHECKBOXES"

  # Take snapshot to generate refs
  bcli snapshot -ic

  # Click the first element ref (should be a checkbox)
  run bcli click @e1
  [ "$status" -eq 0 ]
  [[ "$output" == *"Clicked"* ]]
}

@test "click @e ref: click button using element ref" {
  navigate_and_wait "$URL_LOGIN"

  # Take snapshot to generate refs
  bcli snapshot -ic

  # We know the login page has multiple interactive elements
  # The button should be one of the refs
  run bcli click @e3
  [ "$status" -eq 0 ]
  [[ "$output" == *"Clicked"* ]]
}

# ─── Fill with Element Ref ────────────────────────────────────────────

@test "fill @e ref: fill input using element ref" {
  navigate_and_wait "$URL_LOGIN"

  # Take snapshot to generate refs
  bcli snapshot -ic

  # @e1 should be the username input on the login page
  run bcli fill @e1 "$TEST_USERNAME"
  [ "$status" -eq 0 ]
  [[ "$output" == *"Filled"* ]]

  # Verify the field was actually filled
  assert_value_equals "$SEL_USERNAME" "$TEST_USERNAME"
}

@test "fill @e ref: fill password using element ref" {
  navigate_and_wait "$URL_LOGIN"

  # Take snapshot to generate refs
  bcli snapshot -ic

  # @e2 should be the password input on the login page
  run bcli fill @e2 "$TEST_PASSWORD"
  [ "$status" -eq 0 ]
  [[ "$output" == *"Filled"* ]]

  assert_value_equals "$SEL_PASSWORD" "$TEST_PASSWORD"
}

# ─── Hover with Element Ref ──────────────────────────────────────────

@test "hover @e ref: hover using element ref" {
  navigate_and_wait "$URL_LOGIN"

  bcli snapshot -ic

  run bcli hover @e1
  [ "$status" -eq 0 ]
  [[ "$output" == *"Hovered"* ]]
}

# ─── Focus with Element Ref ──────────────────────────────────────────

@test "focus @e ref: focus using element ref" {
  navigate_and_wait "$URL_LOGIN"

  bcli snapshot -ic

  run bcli focus @e1
  [ "$status" -eq 0 ]
  [[ "$output" == *"Focused"* ]]
}

# ─── Type with Element Ref ───────────────────────────────────────────

@test "type @e ref: type text using element ref" {
  navigate_and_wait "$URL_LOGIN"

  bcli snapshot -ic

  run bcli type @e1 "testuser"
  [ "$status" -eq 0 ]
  [[ "$output" == *"Typed"* ]]
}

# ─── Clear with Element Ref ──────────────────────────────────────────

@test "clear @e ref: clear input using element ref" {
  navigate_and_wait "$URL_LOGIN"

  bcli snapshot -ic

  # First fill the input
  bcli fill @e1 "testdata"

  # Then clear it using the same ref
  run bcli clear @e1
  [ "$status" -eq 0 ]
  [[ "$output" == *"Cleared"* ]]

  assert_value_equals "$SEL_USERNAME" ""
}

# ─── Get Data with Element Ref ───────────────────────────────────────

@test "get text @e ref: get text content using element ref" {
  navigate_and_wait "$URL_LOGIN"

  # Snapshot to get refs
  bcli snapshot -ic

  # One of the refs should correspond to a button or element with text
  run bcli get text @e3
  [ "$status" -eq 0 ]
  # Should return some text content
  [ -n "$output" ]
}

@test "get value @e ref: get value using element ref" {
  navigate_and_wait "$URL_LOGIN"

  bcli snapshot -ic

  # Fill the username field
  bcli fill @e1 "checkvalue"

  run bcli get value @e1
  [ "$status" -eq 0 ]
  [[ "$output" == *"checkvalue"* ]]
}

# ─── Check/Uncheck with Element Ref ──────────────────────────────────

@test "check @e ref: check checkbox using element ref" {
  navigate_and_wait "$URL_CHECKBOXES"

  bcli snapshot -ic

  run bcli check @e1
  [ "$status" -eq 0 ]
  [[ "$output" == *"Checked"* ]]
}

@test "uncheck @e ref: uncheck checkbox using element ref" {
  navigate_and_wait "$URL_CHECKBOXES"

  bcli snapshot -ic

  # @e2 should be the second checkbox (checked by default)
  run bcli uncheck @e2
  [ "$status" -eq 0 ]
  [[ "$output" == *"Unchecked"* ]]
}

# ─── Refs are Regenerated on Each Snapshot ────────────────────────────

@test "refs are regenerated on new snapshot" {
  navigate_and_wait "$URL_LOGIN"

  # First snapshot
  bcli snapshot -ic

  # Fill using @e1
  bcli fill @e1 "first-run"
  assert_value_equals "$SEL_USERNAME" "first-run"

  # Navigate to a different page and back
  navigate_and_wait "$URL_CHECKBOXES"
  navigate_and_wait "$URL_LOGIN"

  # Take new snapshot — refs should be regenerated
  bcli snapshot -ic

  # @e1 should still work (regenerated for the new page state)
  run bcli fill @e1 "second-run"
  [ "$status" -eq 0 ]
  [[ "$output" == *"Filled"* ]]

  assert_value_equals "$SEL_USERNAME" "second-run"
}

# ─── Stale Ref Error ─────────────────────────────────────────────────

@test "stale ref: ref from old page gives error after navigation" {
  navigate_and_wait "$URL_LOGIN"

  # Take snapshot to generate refs
  bcli snapshot -ic

  # Navigate to a different page (refs should become stale)
  navigate_and_wait "$URL_CHECKBOXES"

  # Try to use the old ref — should fail
  run bcli click @e1
  # This might succeed if the CSS selector fallback works,
  # or fail if the element no longer exists
  # Either outcome is acceptable; the key test is whether it doesn't crash
  true
}

@test "nonexistent ref gives error" {
  navigate_and_wait "$URL_LOGIN"

  # Take snapshot to generate refs
  bcli snapshot -ic

  # Try to use a ref that doesn't exist (@e999)
  run bcli click @e999
  [ "$status" -ne 0 ]
  [[ "$output" == *"not found"* ]] || [[ "$output" == *"Element"* ]]
}

# ─── Refs with Different Snapshot Flags ───────────────────────────────

@test "snapshot -i produces refs for interactive elements only" {
  navigate_and_wait "$URL_LOGIN"

  run bcli snapshot -i
  [ "$status" -eq 0 ]

  # Should have refs for interactive elements
  [[ "$output" == *"@e"* ]]
}

@test "snapshot -c produces compact output with refs" {
  navigate_and_wait "$URL_LOGIN"

  run bcli snapshot -c
  [ "$status" -eq 0 ]

  # Compact mode should still include refs
  [[ "$output" == *"@e"* ]]
}

@test "snapshot with -s selector scopes refs" {
  navigate_and_wait "$URL_LOGIN"

  run bcli snapshot -ic -s "form"
  [ "$status" -eq 0 ]

  # Scoped snapshot should still have refs but only for form elements
  [[ "$output" == *"@e"* ]]
}

# ─── Complete Workflow with Refs ──────────────────────────────────────

@test "complete workflow: snapshot + ref-based login" {
  navigate_and_wait "$URL_LOGIN"

  # Take snapshot to generate refs
  bcli snapshot -ic

  # Fill username using ref
  bcli fill @e1 "$TEST_USERNAME"

  # Fill password using ref
  bcli fill @e2 "$TEST_PASSWORD"

  # Click login button using ref
  bcli click @e3

  # Wait for navigation
  sleep 2

  assert_url_matches "/secure"
}
